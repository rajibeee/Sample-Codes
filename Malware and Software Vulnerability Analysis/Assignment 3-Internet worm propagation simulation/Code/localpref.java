/* Rajib Dey */
/* CAP 6135 - Spring 2018 */
/* Programing Project Assignment 3 */

import java.io.File;
import java.io.FileWriter;
import java.io.IOException;

enum Node {
	notInfected, Vulnerable, infected; // setting up 3 types of enumarator
}

public class localpref {
	public static void main(String args[]) throws IOException {
		
		int maxTime=2500; // Setting Maximum time tick as 2500
		int results[][] = new int[maxTime+1][4];
		int maxTick=0;
		boolean tickFlag= true;
		for (int simCount = 1; simCount <= 3; simCount++) {
			final int TotalIP = 100000;
			int notFinished=1;
			tickFlag= true;
			Node nodeStatus[] = new Node[TotalIP + 1];
			for (int i = 1; i <= TotalIP; i++) {
				nodeStatus[i] = Node.notInfected;

			}
			// Identifying all the vulnerable computers
			for (int j = 0; j < 100; j++) {
				for (int i = 1; i <= 10; i++) {

					nodeStatus[i + (j * 1000)] = Node.Vulnerable; //Assigning enumarators for them

				}
			}

			int tick = 0;
			int infectedCount = 1;
			Node priorNodeStatus[] = new Node[TotalIP + 1];
			Node nextNodeStatus[] = new Node[TotalIP + 1];
			for (int i = 1; i <= TotalIP; i++) {
				priorNodeStatus[i] = Node.notInfected;
				nextNodeStatus[i] = Node.notInfected;
			}


			nodeStatus[1] = Node.infected;
			priorNodeStatus[1] = Node.infected;
			nextNodeStatus[1] = Node.infected;
			int tickToInfectAll=0;
			while (tick < maxTime) {
				tick = tick + 1;

				for (int i = 1; i <= TotalIP; i++) {

					if (priorNodeStatus[i] == Node.infected) {
						float probability = (float) (Math.random());

						if (probability <= 0.8) { //Following the instructions given
							int low = 0;
							int high = TotalIP;

							if (i <= 10) {
								low = 1;
								high = i + 10;
							} else if (i > 99990) {
								high = TotalIP;
								low = i - 10;
							} else {
								low = i - 10;
								high = i + 10;
							}
							int range = high - low;

							for (int j = 1; j <= 3; j++) { // Eta= 3
								int random_ip = (int) (Math.random() * range) + low;
								if (nodeStatus[random_ip] == Node.Vulnerable) {
									nodeStatus[random_ip] = Node.infected;
									infectedCount++;
									priorNodeStatus[random_ip] = Node.infected;

								}

							}

						} else {
							for (int j = 1; j <= 3; j++) { // Eta= 3

								int random_ip = (int) (Math.random() * TotalIP) + 1;
								if (nodeStatus[random_ip] == Node.Vulnerable) {
									nodeStatus[random_ip] = Node.infected;
									infectedCount++;
									priorNodeStatus[random_ip] = Node.infected;
								}

							}
						}

					}

				}

				results[tick][simCount] = infectedCount;
				notFinished=0;
				
				for (int j = 0; j < 100; j++) {   // Finding time when all vulnerable computers got infected
					for (int i = 1; i <= 10; i++) {

						if(nodeStatus[i + (j * 1000)] == Node.Vulnerable)
							notFinished=1;
					}
				}
				if(notFinished==0 && tickFlag== true){
					tickToInfectAll=tick;
					tickFlag= false;
				}
			}
			System.out.println("Total Time Tick for simulation #"+simCount+" to infect all vulnarable IP is = " +tickToInfectAll+ " tick");
			if(tickToInfectAll>maxTick)
				maxTick=tickToInfectAll;
		}

		for (int k = 1; k <= maxTick; k++) {
			for (int i = 1; i <= 3; i++) {
				
			}
			
		}
		try {
			File file = new File("localref.txt");
			file.createNewFile();
			FileWriter writer = new FileWriter(file, true);
			for (int k = 1; k <= maxTick+200; k++) {
				
				for (int i = 1; i <= 3; i++) {
					writer.write(results[k][i] + " ");

				}
				writer.write("\n");

			}
			writer.close();
		} catch (IOException e) {
			e.printStackTrace();
		}

	}
}
